{"version":3,"sources":["globals.js","rgb.js","predictor.js","compression/basedecoder.js","compression/raw.js","compression/lzw.js","compression/jpeg.js","compression/deflate.js","compression/packbits.js","compression/index.js","resample.js","geotiffimage.js","dataview64.js","dataslice.js","pool.js","source.js","utils.js","geotiffwriter.js","logging.js","geotiff.js"],"names":["fieldTagNames","fieldTags","key","hasOwnProperty","parseInt","fieldTagTypes","arrayFields","BitsPerSample","ExtraSamples","SampleFormat","StripByteCounts","StripOffsets","StripRowCounts","TileByteCounts","TileOffsets","fieldTypeNames","fieldTypes","photometricInterpretations","WhiteIsZero","BlackIsZero","RGB","Palette","TransparencyMask","CMYK","YCbCr","CIELab","ICCLab","ExtraSamplesValues","Unspecified","Assocalpha","Unassalpha","geoKeyNames","geoKeys","fromWhiteIsZero","raster","max","width","height","rgbRaster","Uint8Array","value","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","r","g","b","x","z","Math","min","decodeRowAcc","row","stride","offset","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","applyPredictor","block","predictor","bitsPerSample","planarConfiguration","Error","byteLength","Uint16Array","Uint32Array","BaseDecoder","decode","fileDirectory","buffer","decoded","decodeBlock","Predictor","isTiled","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","PlanarConfiguration","RawDecoder","MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","d","a","floor","de","ef","fg","dg","console","warn","chunk1","chunks","chunk2","hi","appendReversed","dest","source","push","decompress","input","dictionaryIndex","dictionaryChar","dictionaryLength","initDictionary","getNext","byte","addToDictionary","getDictionaryReversed","n","rev","result","code","oldCode","val","oldVal","undefined","LZWDecoder","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","values","children","p","q","pop","decodeScan","data","initialOffset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","initialLength","receiveAndExtend","eobrun","successiveACState","successiveACNextValue","decodeMcu","component","decodeFunction","mcu","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","blocksPerLine","componentsLength","decodeFn","decodeDCFirst","zz","t","huffmanTableDC","diff","pred","decodeDCSuccessive","decodeACFirst","e","rs","huffmanTableAC","s","decodeACSuccessive","direction","decodeBaseline","marker","mcuExpected","blocksPerColumn","mcusPerColumn","usedResetInterval","buildComponentData","lines","samplesPerLine","R","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","JpegStreamReader","constructor","jfif","adobe","quantizationTables","huffmanTablesAC","huffmanTablesDC","resetFrames","frames","parse","readUint16","readDataBlock","subarray","prepareComponents","maxH","componentId","maxV","ceil","scanLines","blocksPerLineForMcu","blocksPerColumnForMcu","fileMarker","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","precision","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","getResult","cp","Object","keys","outComponents","scaleX","scaleY","out","oi","JpegDecoder","reader","JPEGTables","DeflateDecoder","PackbitsDecoder","dataView","DataView","header","getInt8","next","getUint8","getDecoder","Compression","copyNewSize","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","GeoTIFFImage","sum","start","end","arrayForType","format","size","Int8Array","Int16Array","Float32Array","Float64Array","littleEndian","cache","tiles","getFileDirectory","getGeoKeys","getWidth","getHeight","getSamplesPerPixel","SamplesPerPixel","getTileWidth","getTileHeight","getBytesPerPixel","bits","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","prototype","getUint16","getUint32","getInt16","getInt32","getFloat32","getFloat64","getArrayForSample","getTileOrStrip","poolOrDecoder","numTilesPerRow","numTilesPerCol","byteCount","fetch","request","_readRaster","imageWindow","interleave","resampleMethod","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","si","promise","then","tile","firstLine","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","call","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","numPixels","reject","apply","fill","Array","isArray","readRGB","enableAlpha","pi","PhotometricInterpretation","subOptions","ColorMap","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","xmlDom","substring","tagName","root","items","filter","child","item","Number","attributes","name","getGDALNoData","GDAL_NODATA","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","covers","readUint8","readInt8","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","Pool","defaultPoolSize","navigator","hardwareConcurrency","worker","Worker","resolve","queue","err","destroy","terminate","readRangeFromBlocks","rangeOffset","rangeLength","rangeTop","rangeData","ArrayBuffer","rangeView","delta","topDelta","top","blockInnerOffset","usedBlockLength","rangeInnerOffset","blockView","set","getCoherentBlockGroups","blockIds","groups","current","wait","milliseconds","setTimeout","BlockedSource","retrievalFunction","blockSize","blockRequests","Map","blockIdsAwaitingRequest","immediate","allBlockIds","missingBlockIds","blockId","has","get","id","add","Set","from","sort","group","requestData","response","o","delete","missingRequests","requestedOffset","requestedLength","makeFetchSource","url","headers","Range","ok","status","makeXHRSource","XMLHttpRequest","open","responseType","requestHeaders","entries","setRequestHeader","onload","onerror","send","makeHttpSource","parsed","urlMod","protocol","http","https","on","chunk","Buffer","concat","makeRemoteSource","options","forceXHR","makeBufferSource","closeAsync","fd","openAsync","path","flags","mode","readAsync","args","bytesRead","makeFileSource","fileOpen","alloc","close","makeFileReaderSource","file","blob","FileReader","event","target","readAsArrayBuffer","assign","iterable","results","lengthOfIterable","chunked","ci","endsWith","expectedEnding","actualEnding","substr","forEach","func","invert","oldObj","newObj","range","times","numTimes","toArray","toArrayRecursively","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","oincr","readUshort","buff","readShort","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","writeUint","writeASCII","charCodeAt","writeDouble","_writeIFD","bin","_offset","ifd","eoff","tag","typeName","typeNum","num","dlen","toff","encodeIfds","ifds","ifdo","noffs","encodeImage","prfx","img","convertToTids","error","metadataDefaults","writeGeotiff","numBands","flattenedValues","rowIndex","columnIndex","bandIndex","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","GeoAsciiParams","log","encodedMetadata","outputImage","DummyLogger","info","time","timeEnd","LOGGER","setLogger","logger","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","getValues","dataSlice","readMethod","fieldTypeLength","TextDecoder","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","actualOffset","indexOf","requestIFD","previousIfd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","split","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","fromUrl","fromArrayBuffer","fromFile","fromBlob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer"],"mappings":"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","file":"geotiff.js","sourceRoot":"../src","sourcesContent":["export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class RawDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nexport default class JpegDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n","import { inflate } from 'pako/lib/inflate';\nimport BaseDecoder from './basedecoder';\n\nexport default class DeflateDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return inflate(new Uint8Array(buffer)).buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class PackbitsDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n","import RawDecoder from './raw';\nimport LZWDecoder from './lzw';\nimport JpegDecoder from './jpeg';\nimport DeflateDecoder from './deflate';\nimport PackbitsDecoder from './packbits';\n\nexport function getDecoder(fileDirectory) {\n  switch (fileDirectory.Compression) {\n    case undefined:\n    case 1: // no compression\n      return new RawDecoder();\n    case 5: // LZW\n      return new LZWDecoder();\n    case 6: // JPEG\n      throw new Error('old style JPEG compression is not supported.');\n    case 7: // JPEG\n      return new JpegDecoder(fileDirectory);\n    case 8: // Deflate as recognized by Adobe\n    case 32946: // Deflate GDAL default\n      return new DeflateDecoder();\n    case 32773: // packbits\n      return new PackbitsDecoder();\n    default:\n      throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/* eslint max-len: [\"error\", { \"code\": 120 }] */\n\nimport txml from 'txml';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb';\nimport { getDecoder } from './compression';\nimport { resample, resampleInterleaved } from './resample';\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      switch (bitsPerSample) {\n        case 8:\n          return new Uint8Array(size);\n        case 16:\n          return new Uint16Array(size);\n        case 32:\n          return new Uint32Array(size);\n        default:\n          break;\n      }\n      break;\n    case 2: // twos complement signed integer data\n      switch (bitsPerSample) {\n        case 8:\n          return new Int8Array(size);\n        case 16:\n          return new Int16Array(size);\n        case 32:\n          return new Int32Array(size);\n        default:\n          break;\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return this.fileDirectory.SamplesPerPixel;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bitsPerSample = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      const bits = this.fileDirectory.BitsPerSample[i];\n      if ((bits % 8) !== 0) {\n        throw new Error(`Sample bit-width of ${bits} is not supported.`);\n      } else if (bits !== this.fileDirectory.BitsPerSample[0]) {\n        throw new Error('Differing size of samples in a pixel are not supported.');\n      }\n      bitsPerSample += bits;\n    }\n    return bitsPerSample / 8;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    const bits = this.fileDirectory.BitsPerSample[i];\n    if ((bits % 8) !== 0) {\n      throw new Error(`Sample bit-width of ${bits} is not supported.`);\n    }\n    return (bits / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        switch (bitsPerSample) {\n          case 8:\n            return DataView.prototype.getUint8;\n          case 16:\n            return DataView.prototype.getUint16;\n          case 32:\n            return DataView.prototype.getUint32;\n          default:\n            break;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        switch (bitsPerSample) {\n          case 8:\n            return DataView.prototype.getInt8;\n          case 16:\n            return DataView.prototype.getInt16;\n          case 32:\n            return DataView.prototype.getInt32;\n          default:\n            break;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = await this.source.fetch(offset, byteCount);\n\n    // either use the provided pool or decoder to decode the data\n    let request;\n    if (tiles === null) {\n      request = poolOrDecoder.decode(this.fileDirectory, slice);\n    } else if (!tiles[index]) {\n      request = poolOrDecoder.decode(this.fileDirectory, slice);\n      tiles[index] = request;\n    }\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {Pool} pool The decoder pool\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(this.getWidth() / this.getTileWidth()),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(this.getHeight() / this.getTileHeight()),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = (tile.y + 1) * tileHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(tileHeight, tileHeight - (lastLine - imageWindow[3]));\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]));\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is\n   *                                 not the same as the images, resampling will be\n   *                                 performed.\n   * @param {number} [options.height] The desired height of the output. When the width\n   *                                  is not the same as the images, resampling will\n   *                                  be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When\n   *                                              multiple samples are requested, an\n   *                                              array of fill values can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < this.fileDirectory.SamplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= this.fileDirectory.SamplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Number} [pool=null] The optional decoder pool to use.\n   * @param {number} [width] The desired width of the output. When the width is no the\n   *                         same as the images, resampling will be performed.\n   * @param {number} [height] The desired height of the output. When the width is no the\n   *                          same as the images, resampling will be performed.\n   * @param {string} [resampleMethod='nearest'] The desired resampling method.\n   * @param {bool} [enableAlpha=false] Enable reading alpha channel if present.\n   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, pool = null, width, height, resampleMethod, enableAlpha = false } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave: true,\n        samples: s,\n        pool,\n        width,\n        height,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {Number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n    const xmlDom = txml(string.substring(0, string.length - 1));\n\n    if (!xmlDom[0].tagName) {\n      throw new Error('Failed to parse GDAL metadata XML.');\n    }\n\n    const root = xmlDom[0];\n    if (root.tagName !== 'GDALMetadata') {\n      throw new Error('Unexpected GDAL metadata XML tag.');\n    }\n\n    let items = root.children\n      .filter((child) => child.tagName === 'Item');\n\n    if (sample !== null) {\n      items = items.filter((item) => Number(item.attributes.sample) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[item.attributes.name] = item.children[0];\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {Number} or null\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","export default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) >\n      0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i)\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { Pool as tPool, spawn, Worker, Transfer } from 'threads';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : null;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} size The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {Worker} worker The decoder worker, loaded and initialised. Enables\n   *                        loading the worker using worker-loader(or others) externally\n   *                        when using this library as a webpack dependency.\n   */\n  constructor(size = defaultPoolSize, worker = new Worker('./decoder.worker.js')) {\n    this.pool = tPool(() => spawn(worker), size);\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise.<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    return new Promise((resolve, reject) => {\n      this.pool.queue(async (decode) => {\n        try {\n          const data = await decode(fileDirectory, Transfer(buffer));\n          resolve(data);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  destroy() {\n    this.pool.terminate(true);\n  }\n}\n\nexport default Pool;\n","import { Buffer } from 'buffer';\nimport { open, read, close } from 'fs';\nimport http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\n\nfunction readRangeFromBlocks(blocks, rangeOffset, rangeLength) {\n  const rangeTop = rangeOffset + rangeLength;\n  const rangeData = new ArrayBuffer(rangeLength);\n  const rangeView = new Uint8Array(rangeData);\n\n  for (const block of blocks) {\n    const delta = block.offset - rangeOffset;\n    const topDelta = block.top - rangeTop;\n    let blockInnerOffset = 0;\n    let rangeInnerOffset = 0;\n    let usedBlockLength;\n\n    if (delta < 0) {\n      blockInnerOffset = -delta;\n    } else if (delta > 0) {\n      rangeInnerOffset = delta;\n    }\n\n    if (topDelta < 0) {\n      usedBlockLength = block.length - blockInnerOffset;\n    } else {\n      usedBlockLength = rangeTop - block.offset - blockInnerOffset;\n    }\n\n    const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n    rangeView.set(blockView, rangeInnerOffset);\n  }\n\n  return rangeData;\n}\n\n/**\n * Interface for Source objects.\n * @interface Source\n */\n\n/**\n * @function Source#fetch\n * @summary The main method to retrieve the data from the source.\n * @param {number} offset The offset to read from in the source\n * @param {number} length The requested number of bytes\n */\n\n/**\n * @typedef {object} Block\n * @property {ArrayBuffer} data The actual data of the block.\n * @property {number} offset The actual offset of the block within the file.\n * @property {number} length The actual size of the block in bytes.\n */\n\n/**\n * Callback type for sources to request patches of data.\n * @callback requestCallback\n * @async\n * @param {number} offset The offset within the file.\n * @param {number} length The desired length of data to be read.\n * @returns {Promise<Block>} The block of data.\n */\n\n/**\n * @module source\n */\n\n/*\n * Split a list of identifiers to form groups of coherent ones\n */\nfunction getCoherentBlockGroups(blockIds) {\n  if (blockIds.length === 0) {\n    return [];\n  }\n\n  const groups = [];\n  let current = [];\n  groups.push(current);\n\n  for (let i = 0; i < blockIds.length; ++i) {\n    if (i === 0 || blockIds[i] === blockIds[i - 1] + 1) {\n      current.push(blockIds[i]);\n    } else {\n      current = [blockIds[i]];\n      groups.push(current);\n    }\n  }\n  return groups;\n}\n\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n/**\n * BlockedSource - an abstraction of (remote) files.\n * @implements Source\n */\nclass BlockedSource {\n  /**\n   * @param {requestCallback} retrievalFunction Callback function to request data\n   * @param {object} options Additional options\n   * @param {object} options.blockSize Size of blocks to be fetched\n   */\n  constructor(retrievalFunction, { blockSize = 65536 } = {}) {\n    this.retrievalFunction = retrievalFunction;\n    this.blockSize = blockSize;\n\n    // currently running block requests\n    this.blockRequests = new Map();\n\n    // already retrieved blocks\n    this.blocks = new Map();\n\n    // block ids waiting for a batched request. Either a Set or null\n    this.blockIdsAwaitingRequest = null;\n  }\n\n  /**\n   * Fetch a subset of the file.\n   * @param {number} offset The offset within the file to read from.\n   * @param {number} length The length in bytes to read from.\n   * @returns {ArrayBuffer} The subset of the file.\n   */\n  async fetch(offset, length, immediate = false) {\n    const top = offset + length;\n\n    // calculate what blocks intersect the specified range (offset + length)\n    // determine what blocks are already stored or beeing requested\n    const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n    const allBlockIds = [];\n    const missingBlockIds = [];\n    const blockRequests = [];\n\n    for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n      const blockId = Math.floor(current / this.blockSize);\n      if (!this.blocks.has(blockId) && !this.blockRequests.has(blockId)) {\n        missingBlockIds.push(blockId);\n      }\n      if (this.blockRequests.has(blockId)) {\n        blockRequests.push(this.blockRequests.get(blockId));\n      }\n      allBlockIds.push(blockId);\n    }\n\n    // determine whether there are already blocks in the queue to be requested\n    // if so, add the missing blocks to this list\n    if (!this.blockIdsAwaitingRequest) {\n      this.blockIdsAwaitingRequest = new Set(missingBlockIds);\n    } else {\n      for (let i = 0; i < missingBlockIds.length; ++i) {\n        const id = missingBlockIds[i];\n        this.blockIdsAwaitingRequest.add(id);\n      }\n    }\n\n    // in immediate mode, we don't want to wait for possible additional requests coming in\n    if (!immediate) {\n      await wait();\n    }\n\n    // determine if we are the thread to start the requests.\n    if (this.blockIdsAwaitingRequest) {\n      // get all coherent blocks as groups to be requested in a single request\n      const groups = getCoherentBlockGroups(\n        Array.from(this.blockIdsAwaitingRequest).sort(),\n      );\n\n      // iterate over all blocks\n      for (const group of groups) {\n        // fetch a group as in a single request\n        const request = this.requestData(\n          group[0] * this.blockSize, group.length * this.blockSize,\n        );\n\n        // for each block in the request, make a small 'splitter',\n        // i.e: wait for the request to finish, then cut out the bytes for\n        // that block and store it there.\n        // we keep that as a promise in 'blockRequests' to allow waiting on\n        // a single block.\n        for (let i = 0; i < group.length; ++i) {\n          const id = group[i];\n          this.blockRequests.set(id, (async () => {\n            const response = await request;\n            const o = i * this.blockSize;\n            const t = Math.min(o + this.blockSize, response.data.byteLength);\n            const data = response.data.slice(o, t);\n            this.blockRequests.delete(id);\n            this.blocks.set(id, {\n              data,\n              offset: response.offset + o,\n              length: data.byteLength,\n              top: response.offset + t,\n            });\n          })());\n        }\n      }\n      this.blockIdsAwaitingRequest = null;\n    }\n\n    // get a list of currently running requests for the blocks still missing\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // wait for all missing requests to finish\n    await Promise.all(missingRequests);\n    await Promise.all(blockRequests);\n\n    // now get all blocks for the request and return a summary buffer\n    const blocks = allBlockIds.map((id) => this.blocks.get(id));\n    return readRangeFromBlocks(blocks, offset, length);\n  }\n\n  async requestData(requestedOffset, requestedLength) {\n    const response = await this.retrievalFunction(requestedOffset, requestedLength);\n    if (!response.length) {\n      response.length = response.data.byteLength;\n    } else if (response.length !== response.data.byteLength) {\n      response.data = response.data.slice(0, response.length);\n    }\n    response.top = response.offset + response.length;\n    return response;\n  }\n}\n\n/**\n * Create a new source to read from a remote file using the\n * [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} API.\n * @param {string} url The URL to send requests to.\n * @param {Object} [options] Additional options.\n * @param {Number} [options.blockSize] The block size to use.\n * @param {object} [options.headers] Additional headers to be sent to the server.\n * @returns The constructed source\n */\nexport function makeFetchSource(url, { headers = {}, blockSize } = {}) {\n  return new BlockedSource(async (offset, length) => {\n    const response = await fetch(url, {\n      headers: {\n        ...headers, Range: `bytes=${offset}-${offset + length - 1}`,\n      },\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = response.arrayBuffer\n        ? await response.arrayBuffer() : (await response.buffer()).buffer;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      const data = response.arrayBuffer\n        ? await response.arrayBuffer() : (await response.buffer()).buffer;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }, { blockSize });\n}\n\n/**\n * Create a new source to read from a remote file using the\n * [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest} API.\n * @param {string} url The URL to send requests to.\n * @param {Object} [options] Additional options.\n * @param {Number} [options.blockSize] The block size to use.\n * @param {object} [options.headers] Additional headers to be sent to the server.\n * @returns The constructed source\n */\nexport function makeXHRSource(url, { headers = {}, blockSize } = {}) {\n  return new BlockedSource(async (offset, length) => {\n    return new Promise((resolve, reject) => {\n      const request = new XMLHttpRequest();\n      request.open('GET', url);\n      request.responseType = 'arraybuffer';\n      const requestHeaders = { ...headers, Range: `bytes=${offset}-${offset + length - 1}` };\n      for (const [key, value] of Object.entries(requestHeaders)) {\n        request.setRequestHeader(key, value);\n      }\n\n      request.onload = () => {\n        const data = request.response;\n        if (request.status === 206) {\n          resolve({\n            data,\n            offset,\n            length,\n          });\n        } else {\n          resolve({\n            data,\n            offset: 0,\n            length: data.byteLength,\n          });\n        }\n      };\n      request.onerror = reject;\n      request.send();\n    });\n  }, { blockSize });\n}\n\n/**\n * Create a new source to read from a remote file using the node\n * [http]{@link https://nodejs.org/api/http.html} API.\n * @param {string} url The URL to send requests to.\n * @param {Object} [options] Additional options.\n * @param {Number} [options.blockSize] The block size to use.\n * @param {object} [options.headers] Additional headers to be sent to the server.\n */\nexport function makeHttpSource(url, { headers = {}, blockSize } = {}) {\n  return new BlockedSource(async (offset, length) => new Promise((resolve, reject) => {\n    const parsed = urlMod.parse(url);\n    const request = (parsed.protocol === 'http:' ? http : https).get(\n      { ...parsed,\n        headers: {\n          ...headers, Range: `bytes=${offset}-${offset + length - 1}`,\n        } }, (result) => {\n        const chunks = [];\n        // collect chunks\n        result.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n\n        // concatenate all chunks and resolve the promise with the resulting buffer\n        result.on('end', () => {\n          const data = Buffer.concat(chunks).buffer;\n          resolve({\n            data,\n            offset,\n            length: data.byteLength,\n          });\n        });\n      },\n    );\n    request.on('error', reject);\n  }), { blockSize });\n}\n\n/**\n * Create a new source to read from a remote file. Uses either XHR, fetch or nodes http API.\n * @param {string} url The URL to send requests to.\n * @param {Object} [options] Additional options.\n * @param {Boolean} [options.forceXHR] Force the usage of XMLHttpRequest.\n * @param {Number} [options.blockSize] The block size to use.\n * @param {object} [options.headers] Additional headers to be sent to the server.\n * @returns The constructed source\n */\nexport function makeRemoteSource(url, options) {\n  const { forceXHR } = options;\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, options);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, options);\n  }\n  if (http.get) {\n    return makeHttpSource(url, options);\n  }\n  throw new Error('No remote source available');\n}\n\n/**\n * Create a new source to read from a local\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The ArrayBuffer to parse the GeoTIFF from.\n * @returns The constructed source\n */\nexport function makeBufferSource(arrayBuffer) {\n  return {\n    async fetch(offset, length) {\n      return arrayBuffer.slice(offset, offset + length);\n    },\n  };\n}\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    close(fd, err => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\n/**\n * Creates a new source using the node filesystem API.\n * @param {string} path The path to the file in the local filesystem.\n * @returns The constructed source\n */\nexport function makeFileSource(path) {\n  const fileOpen = openAsync(path, 'r');\n\n  return {\n    async fetch(offset, length) {\n      const fd = await fileOpen;\n      const { buffer } = await readAsync(fd, Buffer.alloc(length), 0, length, offset);\n      return buffer.buffer;\n    },\n    async close() {\n      const fd = await fileOpen;\n      return await closeAsync(fd);\n    },\n  };\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return {\n    async fetch(offset, length) {\n      return new Promise((resolve, reject) => {\n        const blob = file.slice(offset, offset + length);\n        const reader = new FileReader();\n        reader.onload = (event) => resolve(event.target.result);\n        reader.onerror = reject;\n        reader.readAsArrayBuffer(blob);\n      });\n    },\n  };\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals';\nimport { assign, endsWith, forEach, invert, times } from './utils';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (typeof val === 'undefined') {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['XPosition', 0],\n  ['YPosition', 0],\n  ['ResolutionUnit', 1], // Code 1 for actual pixel count or 2 for pixels per inch.\n  ['ExtraSamples', 0], // should this be an array??\n  ['GeoAsciiParams', 'WGS 84\\u0000'],\n  ['ModelTiepoint', [0, 0, 0, -180, 90, 0]], // raster fits whole globe\n  ['GTModelTypeGeoKey', 2],\n  ['GTRasterTypeGeoKey', 1],\n  ['GeographicTypeGeoKey', 4326],\n  ['GeogCitationGeoKey', 'WGS 84'],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'PhotometricInterpretation',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n","import GeoTIFFImage from './geotiffimage';\nimport DataView64 from './dataview64';\nimport DataSlice from './dataslice';\nimport Pool from './pool';\nimport { makeRemoteSource, makeBufferSource, makeFileSource, makeFileReaderSource } from './source';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals';\nimport { writeGeotiff } from './geotiffwriter';\nimport * as globals from './globals';\nimport * as rgb from './rgb';\nimport { getDecoder } from './compression';\nimport { setLogger } from './logging';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      await this.source.fetch(\n        offset, typeof size !== 'undefined' ? size : fallbackSize,\n      ), offset, this.littleEndian, this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff ?\n      dataSlice.readUint64(offset) :\n      dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff ?\n        dataSlice.readUint64(i + 4) :\n        dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 &&\n        !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter(line => line.length > 0)\n        .map(line => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   */\n  static async fromSource(source, options) {\n    const headerData = await source.fetch(0, 1024);\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, imageFile.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options));\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer));\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path) {\n  return GeoTIFF.fromSource(makeFileSource(path));\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob));\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options));\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport async function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\n"]}